package hone

import (
	"fmt"
	"log"
	"log/syslog"
	"net"
	"os"
	"strconv"
	"encoding/json"
)

// receiver of capture events
type EventChannel chan *CaptureEvent

type CaptureEventType string

// different hone event input modules
type Reader interface {
	OpenCaptureFile()
	CloseCaptureFile()
	StartCapture(*Agent)
	ParseHoneEventLine(*Agent, []byte) *CaptureEvent
}

// a capture event
type CaptureEvent struct {
	Type   CaptureEventType

	// raw event data
	// (disabled)
	Raw []byte

	HostGUID string

	CaptureTimeDelta float64

	ConnectionState string
	Direction       string
	Sockfd          uint64
	Proto           string
	Src             string
	Dst             string
	Len             uint64

	PID  int
	PPID int
	TGID int
	UID  int
	GID  int

	Executable string
	Args       string
}

// capture event type

// class that reads and dispatches capture events
type Agent struct {
	// handler for reading hone events
	EventReader Reader
	
	Logger *syslog.Writer

	// event dispatcher
	EventChan EventChannel

	// internal event handler
	eventChan EventChannel

	// our unique host identifier
	HostGUID string

	// state
	Stopped     bool
	EventCount  uint64

	// client connection state
	ServerAddress     string
	ServerPort        uint
	ServerConn        net.Conn
	ConnectedToServer bool
	ConnectEventChan  chan bool

	// TRACKING EVENT/CONNECTION/PROCESS/SOCKET STATE
	// mapping of sockfd -> last sock event
	SockEvents map[uint64]*CaptureEvent
	// mapping of tgid -> last exec event
	ExecEvents map[int]*CaptureEvent
	// last HEAD (has our HostGUID)
	LastHeadEvent *CaptureEvent

	// proc info of agent
	TGID int

	// reconnect throttling
	connectLastEventCount uint64
}

func NewAgent(serverAddr string, serverPort uint, evtReader Reader) *Agent {
	agent := new(Agent)

	// initialization
	agent.EventReader = evtReader;
	agent.SockEvents = make(map[uint64]*CaptureEvent)
	agent.ExecEvents = make(map[int]*CaptureEvent)
	agent.ConnectEventChan = make(chan bool, 1)
	agent.TGID = os.Getpid() // trust me here
	
	logger, err := syslog.New(syslog.LOG_DEBUG, "hone-agent")
	if err != nil {
		log.Panicf("Error connecting to syslog: %s\n", err)
	}

	agent.Logger = logger

	agent.ServerAddress = serverAddr
	agent.ServerPort = serverPort

	return agent
}

func (agent *Agent) Connect() {
	agent.ConnectEventChan <- true
}

func (agent *Agent) tryConnect() {
	// don't try again until we see more events
	if agent.connectLastEventCount != agent.EventCount {
		agent.connectLastEventCount = agent.EventCount
		return
	}

	if agent.ConnectedToServer {
		return
	}

	// try connecting to collection server
	server := agent.ServerAddress + ":" + strconv.FormatUint(uint64(agent.ServerPort), 10)

	agent.CloseConnection()
	conn, err := net.Dial("tcp", server)

	if err != nil {
		agent.Logger.Debug(fmt.Sprintf("Failed to connect to %s: %s", server, err))
		agent.ConnectedToServer = false
		return
	}

	agent.Logger.Debug(fmt.Sprintf("Connected to %s", server))

	agent.ServerConn = conn
	agent.ConnectedToServer = true

	// send last HEAD event if we have it, to identify outselves
	if agent.LastHeadEvent != nil {
		agent.SendEventToServer(agent.LastHeadEvent)
	}
}

// opens capture, connects to server, returns event channel
func (agent *Agent) Start() EventChannel {
	// listen for connect events
	go func() {
		for {
			<-agent.ConnectEventChan
			agent.tryConnect()
		}
	}()

	// open capture
	agent.EventReader.OpenCaptureFile()

	// open client connection
	go agent.Connect()

	// create a channel to receive capture events
	agent.eventChan = make(EventChannel)
	agent.EventChan = make(EventChannel)

	// start reading file
	go agent.EventReader.StartCapture(agent);

	return agent.EventChan
}

// runs forever, handles events
func (agent *Agent) Run() {
	for {
		evt := <-agent.eventChan
		agent.handleEvent(evt)
	}
}

func (agent *Agent) Stop() {
	agent.Logger.Debug("Stopping agent")
	agent.Stopped = true
	agent.CloseConnection()
}

func (agent *Agent) CloseConnection() {
	agent.ConnectedToServer = false

	if agent.ServerConn != nil {
		agent.ServerConn.Close()
	}

	agent.ServerConn = nil
}

func (agent *Agent) handleEvent(evt *CaptureEvent) {
	// we don't want packets generated by this process (lol!)
	if evt.TGID != 0 && agent.TGID != 0 {
		if evt.TGID == agent.TGID {
			// discard
			return
		}
	}
	if evt.PID != 0 && agent.TGID != 0 {
		if evt.PID == agent.TGID {
			// discard
			return
		}
	}

	agent.SendEventToServer(evt)

	// dispatch event to public channel
	if agent.EventChan != nil {
		go func() {
			agent.EventChan <- evt
		}()
	}
}

func (agent *Agent) DispatchEvent(evt *CaptureEvent) {
	agent.eventChan <- evt
}

func (agent *Agent) SendEventToServer(evt *CaptureEvent) {
	if !agent.ConnectedToServer {
		go agent.Connect()
		return
	}

	// encode as JSON
	jsonStr, err := json.Marshal(evt)
	if err != nil {
		agent.Logger.Debug(err.Error())
		return
	}

	// send newline-terminated JSON event to server
	_, err = fmt.Fprintln(agent.ServerConn, string(jsonStr))
	if err != nil {
		agent.Logger.Info(fmt.Sprintf("Failed writing event to server: %s\n", err))
		agent.CloseConnection()
		agent.Connect()
	}
}


// fills in missing data if we have it lying around
func (agent *Agent) FillInEvent(evt *CaptureEvent) {
	if evt.Sockfd != 0 {
		// attempt to locate corresponding info for this socket
		// find last sock event of matching sockfd
		sockEvt := agent.SockEvents[evt.Sockfd]
		if sockEvt != nil {
			evt.PID  = sockEvt.PID
			evt.PPID = sockEvt.PPID
			evt.TGID = sockEvt.TGID
			evt.UID  = sockEvt.UID
			evt.GID  = sockEvt.GID

			// wouldn't count on these
			if len(evt.Src) == 0 {
				evt.Src = sockEvt.Src
			}
			if len(evt.Dst) == 0 {
				evt.Dst = sockEvt.Dst
			}
			if len(evt.Proto) == 0 {
				evt.Proto = sockEvt.Proto
			}
			if len(evt.ConnectionState) == 0 {
				evt.ConnectionState = sockEvt.ConnectionState
			}
		} else {
			//fmt.Printf("Failed to find PID for sockFD %d\n\n", evt.Sockfd)
			// we're gonna ignore this, because we have no
			// mapping for the process yet
		}
	}
	
	// attempt to find process info
	if evt.TGID != 0 {
		procInfo := agent.ExecEvents[evt.TGID]
		if procInfo != nil {
			evt.Args = procInfo.Args
			evt.Executable = procInfo.Executable
		} else if evt.PPID != 0 {
			// try to inherit from parent
			parentProc := agent.ExecEvents[evt.PPID]
			if parentProc != nil {
				evt.Executable = parentProc.Executable
				evt.Args = parentProc.Args
				fmt.Println("found parent proc")
			} else {
				//fmt.Printf("failed to find parent proc info in fork\n")
			}
		}
	}
}

func (evt *CaptureEvent) String() string {
	switch evt.Type {
	case "PAKT":
		return fmt.Sprintf("[%d] %s %s %s -> %s %d\n", evt.PID, string(evt.Type), evt.Proto, evt.Src, evt.Dst, evt.Len)
	case "FORK", "EXIT", "EXEC":
		return fmt.Sprintf("[%d] %s (%s)\n", evt.PID, string(evt.Type), evt.Args)
	case "SOCK":
		return fmt.Sprintf("[%d] %s %s %s %s -> %s %d\n", evt.PID, string(evt.Type), string(evt.Direction), evt.Proto, evt.Src, evt.Dst, evt.Len)
	}

	return fmt.Sprintf("[%d] %s", evt.PID, string(evt.Type))
}