package hone

import (
	"bufio"
	"fmt"
	"log"
	"log/syslog"
	"net"
	"os"
	"regexp"
	"strconv"
	"encoding/json"
	"time"
)

const (
	capFilePath = "/dev/honet"
)

// receiver of capture events
type EventChannel chan *CaptureEvent

type CaptureEventType string

// a capture event
type CaptureEvent struct {
	Type   CaptureEventType

	// raw event data
	// (disabled)
	Raw []byte

	HostGUID string

	CaptureTimeDelta float64

	ConnectionState string
	Direction       string
	Sockfd          uint64
	Proto           string
	Src             string
	Dst             string
	Len             uint64

	PID  int
	PPID int
	TGID int
	UID  int
	GID  int

	Executable string
	Args       string
}

// capture event type

// class that reads and dispatches capture events
type Agent struct {
	Logger *syslog.Writer
	
	// reading events from here
	CaptureFile *os.File

	// event dispatcher
	EventChan EventChannel

	// internal event handler
	eventChan EventChannel

	// our unique host identifier
	HostGUID string

	// state
	Stopped     bool
	EventCount  uint64

	// client connection state
	ServerAddress     string
	ServerPort        uint
	ServerConn        net.Conn
	ConnectedToServer bool
	ConnectEventChan  chan bool

	// TRACKING EVENT/CONNECTION/PROCESS/SOCKET STATE
	// mapping of sockfd -> last sock event
	SockEvents map[uint64]*CaptureEvent
	// mapping of tgid -> last exec event
	ExecEvents map[int]*CaptureEvent
	// last HEAD (has our HostGUID)
	LastHeadEvent *CaptureEvent

	// proc info of agent
	TGID int

	// reconnect throttling
	connectLastEventCount uint64
}

func NewAgent(serverAddr string, serverPort uint) *Agent {
	agent := new(Agent)

	// initialization
	agent.SockEvents = make(map[uint64]*CaptureEvent)
	agent.ExecEvents = make(map[int]*CaptureEvent)
	agent.ConnectEventChan = make(chan bool, 1)
	agent.TGID = os.Getpid() // trust me here
	
	logger, err := syslog.New(syslog.LOG_DEBUG, "hone-agent")
	if err != nil {
		log.Panicf("Error connecting to syslog: %s\n", err)
	}

	agent.Logger = logger

	agent.ServerAddress = serverAddr
	agent.ServerPort = serverPort

	return agent
}

func (agent *Agent) Connect() {
	agent.ConnectEventChan <- true
}

func (agent *Agent) tryConnect() {
	// don't try again until we see more events
	if agent.connectLastEventCount != agent.EventCount {
		agent.connectLastEventCount = agent.EventCount
		return
	}

	if agent.ConnectedToServer {
		return
	}

	// try connecting to collection server
	server := agent.ServerAddress + ":" + strconv.FormatUint(uint64(agent.ServerPort), 10)

	agent.CloseConnection()
	conn, err := net.Dial("tcp", server)

	if err != nil {
		agent.Logger.Debug(fmt.Sprintf("Failed to connect to %s: %s", server, err))
		agent.ConnectedToServer = false
		return
	}

	agent.Logger.Debug(fmt.Sprintf("Connected to %s", server))

	agent.ServerConn = conn
	agent.ConnectedToServer = true

	// send last HEAD event if we have it, to identify outselves
	if agent.LastHeadEvent != nil {
		agent.SendEventToServer(agent.LastHeadEvent)
	}
}

// opens capture, connects to server, returns event channel
func (agent *Agent) Start() EventChannel {
	// listen for connect events
	go func() {
		for {
			<-agent.ConnectEventChan
			agent.tryConnect()
		}
	}()

	// open capture
	agent.OpenCaptureFile()

	// open client connection
	go agent.Connect()

	// create a channel to receive capture events
	agent.eventChan = make(EventChannel)
	agent.EventChan = make(EventChannel)

	// start reading file
	go func() {
		for !agent.Stopped {
			if agent.CaptureFile == nil {
				time.Sleep(time.Millisecond * 1000)
				agent.OpenCaptureFile()
				continue
			}
			
			reader := bufio.NewReader(agent.CaptureFile)
			line, isPrefix, err := reader.ReadLine()
			if err != nil {
				agent.Logger.Err(fmt.Sprintf("Error reading capture file: %s\n", err))
				time.Sleep(time.Millisecond * 1000)
				agent.CloseCaptureFile()
				agent.OpenCaptureFile()
				continue
			}

			// partial line? means line is 4k long. not chill.
			if isPrefix {
				log.Panicf("Error finding end-of-line in capture")
				continue
			}

			agent.EventCount++

			// parse input
			evt := agent.ParseHoneEventLine(line)
			if evt == nil {
				continue
			}

			// success
			agent.eventChan <- evt
		}

		agent.CloseCaptureFile()
	}()

	return agent.EventChan
}

// runs forever, handles events
func (agent *Agent) Run() {
	for {
		evt := <-agent.eventChan
		agent.handleEvent(evt)
	}
}

func (agent *Agent) Stop() {
	agent.Logger.Debug("Stopping agent")
	agent.Stopped = true
	agent.CloseConnection()
}

func (agent *Agent) CloseConnection() {
	agent.ConnectedToServer = false

	if agent.ServerConn != nil {
		agent.ServerConn.Close()
	}

	agent.ServerConn = nil
}

func (agent *Agent) handleEvent(evt *CaptureEvent) {
	// we don't want packets generated by this process (lol!)
	if evt.TGID != 0 && agent.TGID != 0 {
		if evt.TGID == agent.TGID {
			// discard
			return
		}
	}
	if evt.PID != 0 && agent.TGID != 0 {
		if evt.PID == agent.TGID {
			// discard
			return
		}
	}

	agent.SendEventToServer(evt)

	// dispatch event to public channel
	if agent.EventChan != nil {
		go func() {
			agent.EventChan <- evt
		}()
	}
}

func (agent *Agent) SendEventToServer(evt *CaptureEvent) {
	if !agent.ConnectedToServer {
		go agent.Connect()
		return
	}

	// encode as JSON
	jsonStr, err := json.Marshal(evt)
	if err != nil {
		agent.Logger.Debug(err.Error())
		return
	}

	// send newline-terminated JSON event to server
	_, err = fmt.Fprintln(agent.ServerConn, string(jsonStr))
	if err != nil {
		agent.Logger.Info(fmt.Sprintf("Failed writing event to server: %s\n", err))
		agent.CloseConnection()
		agent.Connect()
	}
}

// open kernel hone event module
func (agent *Agent) OpenCaptureFile() {
	var err error
	agent.CaptureFile, err = os.Open(capFilePath)

	// TODO: check if module is loaded

	if err != nil {
		agent.Logger.Err(fmt.Sprintf("Error opening capture file for reading: %s\n", err))
	}
}

func (agent *Agent) CloseCaptureFile() {
	agent.CaptureFile.Close()
}

// parses a line from /dev/honet into a CaptureEvent
func (agent *Agent) ParseHoneEventLine(lineBytes []byte) *CaptureEvent {
	line := string(lineBytes)

	parseSuccess := false

	//log.Printf("line: %s\n", line)

	// parse timestamp and event type
	var delta float64
	var eventType CaptureEventType
	parsed, err := fmt.Sscanf(line, "%f %s", &delta, &eventType)

	if err != nil || parsed != 2 {
		if agent.EventCount > 10 {
			// first few lines might be incomplete
			log.Printf("Failed to parse line '%s': %s\n", line, err)
		}
		return nil
	}
	
	// build event
	evt := new(CaptureEvent)
	evt.CaptureTimeDelta = delta
	
	// handle event types
	procSpec := "(\\d+) (\\d+) (\\d+) (\\d+) (\\d+)"
	switch eventType {
	case "EXEC", "EXIT", "FORK":
		// process event
		re := regexp.MustCompile(procSpec + "(?: \"([^\"]+)\" (.+))?")
		matches := re.FindStringSubmatch(line)

		if len(matches) >= 6 {
			evt.PID = parseInt(matches[1])
			evt.PPID = parseInt(matches[2])
			evt.TGID = parseInt(matches[3])
			evt.UID = parseInt(matches[4])
			evt.GID = parseInt(matches[5])
			parseSuccess = true
		}

		if evt.TGID != 0 && parseSuccess && eventType == "EXEC" {
			evt.Executable = matches[6]
			evt.Args = matches[7]

			agent.ExecEvents[evt.TGID] = evt
		}
		
		if parseSuccess && eventType == "EXIT" {
			delete(agent.ExecEvents, evt.TGID)
		}

	case "PAKT":
		// packet
		re := regexp.MustCompile("([IO]) ([A-Fa-f0-9]+) (\\S+) (\\S+) -> (\\S+) (\\d+)")
		matches := re.FindStringSubmatch(line)

		if len(matches) != 7 {
			fmt.Printf("failed to parse PAKT evt '%s'\n", line)
			return nil
		}
		
		evt.Direction = matches[1]
		evt.Proto = matches[3]
		evt.Src = matches[4]
		evt.Dst = matches[5]

		fd, err := strconv.ParseUint(matches[2], 16, 0)
		if err == nil {
			evt.Sockfd = fd
			parseSuccess = true
		} else {
			fmt.Printf("Failed to parse sockfd %s: %s\n", matches[2], err)
			parseSuccess = false
		}

		evtlen, err := strconv.ParseUint(matches[6], 10, 0)
		if err == nil {
			evt.Len = evtlen
			parseSuccess = true
		} else {
			fmt.Printf("Failed to parse length %s: %s\n", matches[6], err)
			parseSuccess = false
		}
		
	case "SOCK":
		// socket
		re := regexp.MustCompile("([CO]) " + procSpec + " ([A-Fa-f0-9]+)")
		matches := re.FindStringSubmatch(line)

		if len(matches) == 8 {
			evt.ConnectionState = matches[1]
			evt.Sockfd, _ = strconv.ParseUint(matches[7], 16, 0)

			evt.PID = parseInt(matches[2])
			evt.PPID = parseInt(matches[3])
			evt.TGID = parseInt(matches[4])
			evt.UID = parseInt(matches[5])
			evt.GID = parseInt(matches[6])

			if evt.PID != 0 && evt.Sockfd != 0 {
				parseSuccess = true
				agent.SockEvents[evt.Sockfd] = evt
			} else {
				fmt.Printf("Failed to find PID/sockfd from SOCK\n");
			}
		} else {
			fmt.Printf("Failed to parse SOCK event: '%s'\n", line)
		}

	case "HEAD":
		// capture header, host GUID
		_, err := fmt.Sscanf(line, "%f %s %s", &delta, &eventType, &evt.HostGUID)
		if err != nil {
			log.Printf("Failed to parse HEAD event: %s\n", err)
		} else {
			parseSuccess = true
			agent.LastHeadEvent = evt
			agent.HostGUID = evt.HostGUID
		}

	default:
		if agent.EventCount > 10 {
			log.Printf("unhandled hone event type: %s\n", eventType)
		}
	}

	if parseSuccess {
		// event is chill
		//evt.Raw = lineBytes
		evt.Type = eventType
		agent.FillInEvent(evt)
		return evt
	}

	return nil
}

// fills in missing data if we have it lying around
func (agent *Agent) FillInEvent(evt *CaptureEvent) {
	if evt.Sockfd != 0 {
		// attempt to locate corresponding info for this socket
		// find last sock event of matching sockfd
		sockEvt := agent.SockEvents[evt.Sockfd]
		if sockEvt != nil {
			evt.PID  = sockEvt.PID
			evt.PPID = sockEvt.PPID
			evt.TGID = sockEvt.TGID
			evt.UID  = sockEvt.UID
			evt.GID  = sockEvt.GID

			// wouldn't count on these
			if len(evt.Src) == 0 {
				evt.Src = sockEvt.Src
			}
			if len(evt.Dst) == 0 {
				evt.Dst = sockEvt.Dst
			}
			if len(evt.Proto) == 0 {
				evt.Proto = sockEvt.Proto
			}
			if len(evt.ConnectionState) == 0 {
				evt.ConnectionState = sockEvt.ConnectionState
			}
		} else {
			//fmt.Printf("Failed to find PID for sockFD %d\n\n", evt.Sockfd)
			// we're gonna ignore this, because we have no
			// mapping for the process yet
		}
	}
	
	// attempt to find process info
	if evt.TGID != 0 {
		procInfo := agent.ExecEvents[evt.TGID]
		if procInfo != nil {
			evt.Args = procInfo.Args
			evt.Executable = procInfo.Executable
		} else if evt.PPID != 0 {
			// try to inherit from parent
			parentProc := agent.ExecEvents[evt.PPID]
			if parentProc != nil {
				evt.Executable = parentProc.Executable
				evt.Args = parentProc.Args
			} else {
				//fmt.Printf("failed to find parent proc info in fork\n")
			}
		}
	}
}

func parseInt(s string) int {
	res, err := strconv.ParseInt(s, 10, 0)
	if err != nil {
		log.Printf("failed to convert '%s' to int\n", s)
	}

	return int(res)
}

func (evt *CaptureEvent) String() string {
	switch evt.Type {
	case "PAKT":
		return fmt.Sprintf("[%d] %s %s %s -> %s %d", evt.PID, string(evt.Type), evt.Proto, evt.Src, evt.Dst, evt.Len)
	case "FORK", "EXIT", "EXEC":
		return fmt.Sprintf("[%d] %s (%s)", evt.PID, string(evt.Type), evt.Args)
	case "SOCK":
		return fmt.Sprintf("[%d] %s %s %s %s -> %s %d", evt.PID, string(evt.Type), string(evt.Direction), evt.Proto, evt.Src, evt.Dst, evt.Len)
	}

	return fmt.Sprintf("[%d] %s", evt.PID, string(evt.Type))
}